<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[网卡Bond介绍]]></title>
      <url>/posts/linux-bond.html</url>
      <content type="html"><![CDATA[<h3 id="总括"><a href="#总括" class="headerlink" title="总括"></a>总括</h3><p>  Bond技术即<figure class="highlight plain"><figcaption><span>IP 地址。Bond技术一般用于解决网卡的单点故障或用于网卡负载较高的场景。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  Bond 的网卡运行在混杂模式(Promisc)下。在正常情况下，网卡只接收目的硬件地址(MAC Address)是自身MAC的以太网帧，过滤其他数据帧，以减轻驱动程序的负担。但是网卡也支持另外一种被称为混杂的模式，运行在此模式下的网卡可以接收网络上所有的数据帧。bonding就运行在这种模式下，而且修改了驱动程序中的MAC地址，将两张或多张网卡的MAC地址改成同一MAC地址。</div><div class="line"></div><div class="line">网卡的bond模式一共有7种，下面详细介绍。</div><div class="line">### 模式0</div><div class="line">  模式0（mode=0，round-robin）：此模式使用轮询策略，即顺序的在每一个被bond的网卡上发送数据包，这种模式提供负载均衡和容错能力。Bond0可以保证bond虚拟网卡和被bond的两张或多张物理网卡拥有相同的MAC地址，其中bond虚拟网卡的MAC地址是其中一张物理网卡的MAC地址，而bond虚拟网卡的MAC地址是根据bond自己实现的一个算法来选择的。</div><div class="line">  在bond0模式下，如果一个连接或者会话的数据包从不同的网口发出，途中再经过不同的链路，则在客户端很有可能会出现数据包无序到达的现象，而无序到达的数据包一般需要重新发送，这样网络的吞吐量就会下降。同时，如果做bond0的两张或多张网卡接到了同一交换机上，还需对其配置聚合模式。</div><div class="line">### 模式1</div><div class="line">  模式1（mode=1，active-backup）：此模式使用主被策略（热备）。在所有做bond1的物理网卡中，同一时刻只有一张网卡被激活，当且仅当活动网卡失效时才会激活其他的网卡。这种模式下做bond的两张或多张网卡的MAC地址和Bond虚拟网卡的MAC地址相同，而Bond的MAC地址是Bond创建启动后活动网卡（Active Slave）的MAC地址。这种模式要求主被网卡能快速的切换，即当主网卡出现故障后能迅速地切换至备用网卡。切换过程中，上层的应用几乎不受影响，因为Bond的驱动程序会临时接管上层应用的数据包，存放至数据缓冲区，等待备用网卡启动后再发送出去。但是如果切换时间过长，则会引起缓冲区的溢出，导致丢包。</div><div class="line">### 模式2</div><div class="line">  模式2（mode=2，balance-xor）：xor为异或运算(二进制位相异为1，相同为0)。此模式的默认选择策略是：</div><div class="line">选择网卡的序号=(源MAC地址 XOR 目标MAC地址) % Slave网卡（从网卡）的数量。</div><div class="line">  其他的传输策略可以通过xmit_hash_policy配置项指定。</div><div class="line">### 模式3</div><div class="line">  模式3（mode=3，broadcast）：使用广播策略，数据包会被广播至所有Slave网卡进行传送。</div><div class="line">### 模式4</div><div class="line">  模式4（mode=4，802.3ad）：使用动态链接聚合策略，启动时会创建一个聚合组，所有Slave网卡共享同样的速率和双工设定。</div><div class="line">必要条件：</div><div class="line">  1．支持使用ethtool工具获取每个slave网卡的速率和双工设定；</div><div class="line">  2．需要交换机支持IEEE 802.3ad 动态链路聚合（Dynamic link aggregation）模式</div><div class="line">### 模式5</div><div class="line">  模式5（mode=5，balance-tlbtransmitload balancing）：基于每个slave网卡的速率选择传输网卡。</div><div class="line">  必要条件：支持使用ethtool工具获取每个slave网卡的速率。</div><div class="line">### 模式6</div><div class="line">  模式6（mode=6，balance-alb，Adaptive load balancing）：该模式包含了bond5模式，同时还支持对IPV4流量接收时的负载均衡策略(receive load balance, rlb)，而且不需要任何交换机的支持。</div><div class="line">必要条件：</div><div class="line">  1. ethtool支持获取每个slave的速率；</div><div class="line">  2. 底层驱动支持设置某个网卡设备的硬件地址。</div><div class="line"></div><div class="line">###   优劣比较</div><div class="line">7中bond模式对比如下</div><div class="line">![](https://ljw.howieli.cn/blog/2017-5-27/bond.png)</div><div class="line">  在7种模式中，最为常用的是bond0和bond1。在网络流量较大的场景下推荐使用bond0；在可靠性要求较高的场景下推荐使用bond1。</div><div class="line"></div><div class="line">### 实践操作</div><div class="line">下面以bond0为例，介绍一下bond的基本配置。具体步骤如下：</div><div class="line">1. 配置前查看是否开启bond模块：modinfo bonding。</div><div class="line">2. 创建bond0网卡配置文件如下：  </div><div class="line">```shell</div><div class="line">vim/etc/sysconfig/network-scripts/ifcfg-bond0:</div><div class="line">    DEVICE=bond0</div><div class="line">    ONBOOT=yes #自动启动</div><div class="line">    BOOTPROTO=dhcp #可以选择dhcp，static，none</div><div class="line">    USERCTL=no #该设备只能由root控制</div><div class="line">    NM_CONTROLLED=no #不需要重启网卡，实时生效</div><div class="line">    TYPE=Ethernet    #如选DHCP则需要配置IP地址等信息</div><div class="line">    #IPADDR=10.0.2.10</div><div class="line">    #NETMASK=255.255.255.0</div><div class="line">    #GATEWAY=10.0.2.1</div><div class="line">    #BONDING_OPTS=&quot;mode=0 miimon=100fail_over_mac=1&quot;</div><div class="line">    #如果使用了BONDING_OPTS选项，则不需要再使用/etc/modprobe.conf 配置文件对绑定设备进行配置。</div></pre></td></tr></table></figure></p>
<ol>
<li><p>配置被bond的网卡。Bonding接口创建以后，被绑定的网卡必须在他们的设置文件里面添加MASTER和SLAVE两个参数。如eth0的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim/etc/sysconfig/network-scripts/ifcfg-eth0:</div><div class="line">    DEVICE=eth0</div><div class="line">    ONBOOT=yes</div><div class="line">    BOOTPROTO=none</div><div class="line">    USERCTL=no</div><div class="line">    NM_CONTROLLED=no</div><div class="line">    MASTER=bond0 #属于哪个bond</div><div class="line">    SLAVE=yes #是否为从网卡，即是否被做bond</div></pre></td></tr></table></figure>
</li>
<li><p>创建并编辑<figure class="highlight plain"><figcaption><span>文件，使系统在启动时加载bonding模块。添加：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```alias bond0 bonding``` //使系统在启动时加载bonding模块，对外虚拟网络接口设备为 bond0</div><div class="line">```options bond0 miimon=100 mode=0 fail_over_mac=1</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>其中miimon是用来进行链路监测的，其原理是检测网上的链路状态，一般将miimon值设为100，表示系统每100ms监测一次链路连接状态，如果有一条线路不通就转入另一条线路。bonding定义了网卡的4个链路状态：正常状态(BOND_LINK_UP)、网卡出现故障(BOND_LINK_FAIL)、失效状态(BOND_LINK_DOWN)和恢复状态(BOND_LINK_BACK)。<br>fail_over_mac默认等于0，当发生错误时只修改slave网卡的MAC地址而不修改bond的MAC地址；fail_over_mac=1时，当发生错误时只修改bond网卡的MAC地址而不修改slave网卡的MAC地址。这个选项只在虚拟机上进行测试时开启，如果使用物理机则不需配置。</p>
<ol>
<li>重启机器，使用<code>cat /proc/net/bonding/bondX</code>命令查看bond配置是否生效。<br> 注：必须关闭NetworkManger服务，否则会和bond冲突</li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux bond </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tmux Linux 分屏工具]]></title>
      <url>/posts/linux-tmux.html</url>
      <content type="html"><![CDATA[<h3 id="tmux介绍"><a href="#tmux介绍" class="headerlink" title="tmux介绍"></a>tmux介绍</h3><a id="more"></a>
<p>tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。<br>有一本关于Tmux的书tmux：<a href="https://www.amazon.com/tmux-Productive-Development-Brian-Hogan/dp/1934356964" target="_blank" rel="external">Productive Mouse-Free Development</a><br>自己在centos7.2系统上简单的使用了一下</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> yum install tmux -y</span></div></pre></td></tr></table></figure>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Ctrl+b ? 显示快捷键帮助</div><div class="line">Ctrl+b C-o 调换窗口位置，类似与vim 里的C-w</div><div class="line">Ctrl+b 空格键 采用下一个内置布局</div><div class="line">Ctrl+b ! 把当前窗口变为新窗口</div><div class="line">Ctrl+b “ 横向分隔窗口</div><div class="line">Ctrl+b % 纵向分隔窗口</div><div class="line">Ctrl+b q 显示分隔窗口的编号</div><div class="line">Ctrl+b o 跳到下一个分隔窗口</div><div class="line">Ctrl+b 上下键 上一个及下一个分隔窗口</div><div class="line">Ctrl+b C-方向键 调整分隔窗口大小</div><div class="line">Ctrl+b c 创建新窗口</div><div class="line">Ctrl+b 0~9 选择几号窗口</div><div class="line">Ctrl+b c 创建新窗口</div><div class="line">Ctrl+b n 选择下一个窗口</div><div class="line">Ctrl+b l 切换到最后使用的窗口</div><div class="line">Ctrl+b p 选择前一个窗口</div><div class="line">Ctrl+b w 以菜单方式显示及选择窗口</div><div class="line">Ctrl+b t 显示时钟</div><div class="line">Ctrl+b ; 切换到最后一个使用的面板</div><div class="line">Ctrl+b x 关闭面板</div><div class="line">Ctrl+b &amp; 关闭窗口</div><div class="line">Ctrl+b s 以菜单方式显示和选择会话</div><div class="line">Ctrl+b d 退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Openstack Ocata vxlan模式搭建]]></title>
      <url>/posts/openstack-ocata.html</url>
      <content type="html"><![CDATA[<h3 id="手动搭建分布式Openstack-Ocata-vxlan模式"><a href="#手动搭建分布式Openstack-Ocata-vxlan模式" class="headerlink" title="手动搭建分布式Openstack Ocata vxlan模式 "></a>手动搭建分布式Openstack Ocata vxlan模式 <a id="more"></a></h3><h4 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h4><h5 id="1、前提准备"><a href="#1、前提准备" class="headerlink" title="1、前提准备"></a>1、前提准备</h5><p>  安装vmaware workstation12.50，虚拟机三台，配置至少cpu4c MEM 4G虚拟机</p>
<h5 id="2、更改hostname"><a href="#2、更改hostname" class="headerlink" title="2、更改hostname"></a>2、更改hostname</h5><p>  如果是controller就运行<br>  <code># hostnameecal set-hostname controller</code><br>参考文章<a href="https://docs.openstack.org/ocata/install-guide-rdo/" target="_blank" rel="external">openstack</a></p>
]]></content>
      
        <categories>
            
            <category> openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack实例启动流程]]></title>
      <url>/posts/openstack-blog.html</url>
      <content type="html"><![CDATA[<h3 id="openstack实例启动流程"><a href="#openstack实例启动流程" class="headerlink" title="openstack实例启动流程"></a>openstack实例启动流程</h3><a id="more"></a>
<p><img src="https://ljw.howieli.cn/blog/2017-5-26/openstack.png" alt=""><br>1.客户端使用自己的用户名密码请求认证。<br>2.keystone通过查询在keystone的数据库user表中保存了user的相关信息，包括password加密后的hash值，并返回一个token_id（令牌），和serviceCatalog(一些服务的endpoint地址，cinder、glance-api后面下载镜像和创建块存储时会用到)。<br>3.客户端带上keystone返回的token_id和创建虚机的相关参数，Post请求nova-api创建虚拟机<br>4.nova-api接收到请求后，首先使用请求携带的token_id来访问该api，以验证请求是否有效。<br>5.keystone验证通过后返回更新后的认证信息。<br>6.nova api检查创建虚拟机参数是否有效与合法。<br>检查虚拟机name是否符合命名规范，flavor_id是否在数据库中存在，image_uuid是否是正确的uuid格式<br>检查instance、vcpu、ram的数量是否超过配额。<br>7.当且仅当所有传参都有效合法时，更新nova数据库，新建一条instance记录，vm_states设为BUILDING，task_state设为SCHEDULING.<br>8.nova api 远程调用传递请求、参数给nova scheduler，把消息“请给我创建一台虚拟机”丢到消息队列，然后定期查询虚机的状态。<br>9.nova scheduler从queue中获取到这条消息<br>10.nova scheduler访问nova 数据库，通过调度算法，过滤出一些合适的计算节点，然后进行排序。<br>11.更新虚机节点信息，返回一个最优节点id给nova scheduler。<br>12.nova scheduler选定host之后，通过rpc调用nova-compute服务，把“创建虚机请求”消息丢个mq。<br>13.nova compute收到创建虚拟机请求的消息<br>nova-compute有个定时任务，定期从数据库中查找到运行在该节点上的所有虚拟机信息，统计得到空闲内存大小和空闲磁盘大小。然后更新数据库compute_node信息，以保证调度的准确性。<br>14.nova compute通过rpc查询nova数据库中虚机的信息例如主机模板和id<br>15.nova conductor从消息队列中拿到请求查询数据库<br>16.nova conductor查询nova数据库<br>17.数据库返回虚机信息<br>18.nova compute从消息队列中获取信息。<br>19.nova compute 请求glance 的rest api，下载所需要的镜像，一般是qcow2的。<br>20.glance api 也会去验证请求的token的有效性。<br>21.glance api 返回镜像信息给nova-compute。<br>22.同理，nova compute请求neutron api配置网络，例如获取虚机ip地址<br>23.验证token的有效性<br>24.neutron返回网络信息<br>25-27 同glance、neutron验证token返回块设备信息<br>28.据上面配置的虚拟机信息，生成xml，写入libvirt,xml文件，然后调用libvirt driver去使用libvirt.xml文件启动虚拟机。</p>
]]></content>
      
        <categories>
            
            <category> openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python环境准备]]></title>
      <url>/posts/python-blog.html</url>
      <content type="html"><![CDATA[<h3 id="pyenv配置"><a href="#pyenv配置" class="headerlink" title="pyenv配置"></a>pyenv配置</h3><a id="more"></a>
<ol>
<li>安装git <code>yum -y install git</code></li>
<li>安装pyenv <code>curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</code></li>
<li><p>配置环境变量，在<code>~/.bash_profile</code>里增加。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=<span class="string">"~/.pyenv/bin:<span class="variable">$PATH</span>"</span></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span></div></pre></td></tr></table></figure>
</li>
<li><p>安装编译工具<code>yum -y install gcc make patch</code></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
